from copy import deepcopy
from dataclasses import dataclass
from datetime import date
from typing import Callable, Optional, Tuple

import matplotlib.pyplot as plt
import numpy as np
import py3Dmol
from matplotlib.colors import rgb2hex
from rdkit import Chem
from scipy.interpolate import RegularGridInterpolator
from skimage import measure

from molops.constants import ANGSTROM_2_BOHR, BOHR_2_ANGSTROM
from molops.emol import EnhancedMol


@dataclass(kw_only=True)
class Grid:
    origin: np.ndarray
    shape: Tuple[int, int, int]
    spacing: Tuple[float, float, float]
    val: np.ndarray
    emol: EnhancedMol
    path: Optional[str] = None

    def __post_init__(self):
        self.pos = self.get_pos()

    def __repr__(self) -> str:
        return (f"Grid:\n"
                f"    origin: {tuple(np.round(self.origin, 3))}\n"
                f"    shape: {tuple(self.shape)}\n"
                f"    spacing: {tuple(np.round(self.spacing, 3))}\n"
                f"    emol: {self.emol}\n"
                f"    path: {self.path}\n")

    @property
    def range(self):
        min_coords = self.origin
        max_coords = self.origin + np.array(self.shape) * np.array(self.spacing)
        return np.stack([min_coords, max_coords], axis=1)

    @property
    def cube_string(self) -> str:
        """Return the cube data as a string in Gaussian cube file format."""
        # output cube coord in Bohr
        outx0, outy0, outz0 = self.origin * ANGSTROM_2_BOHR
        outdx, outdy, outdz = self.spacing * ANGSTROM_2_BOHR

        content = 'Cube file generated by JaxFF\n'
        content += f'{date.today()}\n'
        content += f'{self.emol.num_atoms:>5}{outx0:>13.6f}{outy0:>13.6f}' + \
                   f'{outz0:>13.6f}\n'
        content += f'{self.shape[0]:>5}{outdx:>13.6f}{0:>13.6f}{0:>13.6f}\n'
        content += f'{self.shape[1]:>5}{0:>13.6f}{outdy:>13.6f}{0:>13.6f}\n'
        content += f'{self.shape[2]:>5}{0:>13.6f}{0:>13.6f}{outdz:>13.6f}\n'

        for i in range(self.emol.num_atoms):
            R = self.emol.geometry[i] * ANGSTROM_2_BOHR  # output atom coord in bohr
            atom_charge = self.emol.partial_charges[i]  # atom charge
            line = f'{self.emol.atom_num[i]:>5}{atom_charge:>13.6f}' + \
                f'{R[0]:>13.6f}{R[1]:>13.6f}{R[2]:>13.6f}\n'
            content += line

        val = self.val.reshape(self.shape)
        for i in range(self.shape[0]):
            curr_block = np.array2string(
                np.array(val[i]),
                formatter={
                    'float_kind': lambda x: "{:.9E}".format(x, width=13)},
                max_line_width=110,
                separator='  ',
                threshold=np.inf,
            )
            curr_block = curr_block.replace(
                '[', ' ').replace(']', ' ').replace('  -', ' -') + '\n'
            content += curr_block

        return content

    @classmethod
    def from_cube(cls, path: str):
        with open(path, 'r') as f:
            lines = f.readlines()
        # parse header
        # number of atoms in molecule provided in cube file
        mol_atom_num = int(lines[2].split()[0])
        grid_min_coords = np.array(
            lines[2].split()[1:], dtype=float) * BOHR_2_ANGSTROM  # in Angstrom
        grid_dimensions = (int(lines[3].split()[0]),
                           int(lines[4].split()[0]),
                           int(lines[5].split()[0]))
        grid_spacing = np.array([lines[3].split()[1],
                                 lines[4].split()[2],
                                 lines[5].split()[3]],
                                dtype=float) * BOHR_2_ANGSTROM  # in Angstrom
        # parse cube values
        val_list = []
        for line in lines[6 + mol_atom_num:]:
            val_list.extend(line.split())
        val = np.array(val_list, dtype=float).reshape(-1)
        emol = EnhancedMol.from_cube(path)
        return cls(
            origin=grid_min_coords, 
            shape=grid_dimensions, 
            spacing=grid_spacing, 
            val=val, 
            emol=emol, 
            path=path
        )

    @classmethod
    def from_emol(cls, 
                  emol: EnhancedMol, 
                  padding: float=2.0,
                  spacing: float=0.25) -> 'Grid':
        coords = emol.geometry
        
        min_coords = np.min(coords, axis=0)
        grid_min_coords = min_coords - padding  # in Angstrom
        max_coords = np.max(coords, axis=0)
        grid_max_coords = max_coords + padding  # in Angstrom
        
        x = np.arange(grid_min_coords[0], grid_max_coords[0] + spacing, spacing)
        y = np.arange(grid_min_coords[1], grid_max_coords[1] + spacing, spacing)
        z = np.arange(grid_min_coords[2], grid_max_coords[2] + spacing, spacing)
        
        return cls(
            origin=grid_min_coords,
            shape=(len(x), len(y), len(z)),
            spacing=np.array([spacing] * 3),
            val=None,
            emol=emol
        )

    @classmethod
    def build_vdwgrid(
        cls, 
        emol: EnhancedMol,
        padding: float=2.0,
        spacing: float=0.25,
        sigma: float=0.1
    ) -> 'Grid':
        vdw_grid = cls.from_emol(emol, padding=padding, spacing=spacing)
        vdw_grid.eval(cls._cal_gaussian_value, sigma=sigma, emol=emol)
        return vdw_grid

    @staticmethod
    def _ary2v3(ary):
        return {"x": ary[0], "y": ary[1], "z": ary[2]}

    @staticmethod
    def _cal_gaussian_value(query_pos: np.ndarray, 
                            emol: EnhancedMol,
                            sigma: float) -> np.ndarray:
        coords = emol.geometry
        
        gaussian_sum = 0
        for atom in emol.atoms:
            vdw_radius = Chem.GetPeriodicTable().GetRvdw(atom.GetAtomicNum())
            position = coords[atom.GetIdx()]
            distance = np.linalg.norm(position - query_pos, axis=1)
            gaussian = np.exp(-(distance - vdw_radius) / sigma)
            gaussian_sum += gaussian
        results = -sigma * np.log(gaussian_sum)
        return results

    def get_pos(self) -> np.ndarray:
        x0, y0, z0 = self.origin
        dx, dy, dz = self.spacing
        nx, ny, nz = self.shape
        x = np.array([x0 + i * dx for i in range(nx)], dtype=float)
        y = np.array([y0 + i * dy for i in range(ny)], dtype=float)
        z = np.array([z0 + i * dz for i in range(nz)], dtype=float)
        xx, yy, zz = np.meshgrid(x, y, z, indexing='ij')
        pos = np.stack([xx, yy, zz]).transpose((1, 2, 3, 0)).reshape(-1, 3)
        return pos        

    def eval(self, 
             func: Callable[[np.ndarray], np.ndarray],
             **kwargs) -> np.ndarray:
        self.val = func(self.pos, **kwargs)

    def interpolate(self, query_pos: np.ndarray) -> np.ndarray:
        x0, y0, z0 = self.origin
        dx, dy, dz = self.spacing
        nx, ny, nz = self.shape
        x = np.array([x0 + i * dx for i in range(nx)], dtype=float)
        y = np.array([y0 + i * dy for i in range(ny)], dtype=float)
        z = np.array([z0 + i * dz for i in range(nz)], dtype=float)
        interpolator = RegularGridInterpolator(points=(x, y, z), 
                                               values=self.val.reshape(self.shape))
        return interpolator(query_pos)

    def show_isosurface(self, threshold: float) -> py3Dmol.view:
        view = py3Dmol.view(width=600, height=400)
        view.addModel(self.emol.xyz_block, 'xyz')
        view.addVolumetricData(self.cube_string, "cube", {'isoval': threshold,  
                                                  'color': "lightblue", 
                                                  'opacity': 0.5})
        view.setStyle({'stick':{'colorscheme':'greenCarbon'}})
        view.setBackgroundColor('0xeeeeee')
        view.zoomTo()
        return view

    def get_isosurface(self, threshold: float) -> np.ndarray:
        values = self.val.reshape(self.shape)
        verts, faces, _, _ = measure.marching_cubes(values, 
                                                    threshold, 
                                                    spacing=self.spacing)
        verts = verts + self.origin
        return verts, faces

    def show_on_vdwsurf(
        self, 
        vdw_threshold: float=0.01,
        vdw_sigma: float=0.1,
        vdw_padding: float=1.5,
        vdw_spacing: float=0.25
    ) -> py3Dmol.view:
        vdw_grid = self.__class__.build_vdwgrid(
            self.emol, 
            sigma=vdw_sigma, 
            padding=vdw_padding,
            spacing=vdw_spacing
        )
        verts, faces = vdw_grid.get_isosurface(vdw_threshold)
        verts_val = self.interpolate(verts)
        cm = plt.cm.bwr
        verts_val = (verts_val - verts_val.min()) / (verts_val.max() - verts_val.min())
        view = py3Dmol.view(width=600, height=400)
        view.addModel(self.emol.xyz_block, 'xyz')
        
        for cell in faces:
            normal = self._ary2v3(np.cross(verts[cell[1]] - verts[cell[0]], 
                                           verts[cell[2]] - verts[cell[0]]))
            val = verts_val[cell].mean()
            color = cm(val)
            view.addCustom(
                {
                    "vertexArr": [self._ary2v3(verts[cell[0]]), 
                                   self._ary2v3(verts[cell[1]]), 
                                   self._ary2v3(verts[cell[2]])],
                    "normalArr": [normal, normal, normal],
                    "faceArr": [0, 1, 2],
                    "color": rgb2hex(color),
                    "alpha": 0.8,
                }
            )
        
        view.setStyle({'stick':{'colorscheme':'greenCarbon'}})
        view.setBackgroundColor('0xeeeeee')
        view.zoomTo()
        return view

    def write_cube(self, path: str):
        with open(path, 'w') as f:
            f.write(self.cube_string)
